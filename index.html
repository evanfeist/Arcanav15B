<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Arcana ‚Äî Solo vs AI / Online (Mobile-First)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f16" />

  <style>
    :root{
      --bg:#0b0f16; --panel:#121a24; --panel-2:#0e1520; --ink:#dfe7f5;
      --sub:#9fb3d9; --accent:#6cc4ff; --ok:#5bd39b; --bad:#ff6b7a; --warn:#ffb347;
      --card:#151e2a; --card-h:#192337; --sel:#6cc4ff; --border:#263243;
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --safe-bottom:env(safe-area-inset-bottom,0px);
      --cardRatio:63/112;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:linear-gradient(180deg,#0a0f17,#0b111a 40%,#0a1018);
      color:var(--ink);font:15px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial
    }

    .wrap{display:grid;grid-template-columns:1fr;gap:12px;padding:10px 10px calc(88px + var(--safe-bottom));max-width:760px;margin:0 auto}
    .col{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden;min-height:120px}
    header.sticky{position:sticky;top:0;background:var(--panel-2);border-bottom:1px solid var(--border);z-index:5}
    header.bar{display:flex;align-items:center;gap:8px;justify-content:space-between;padding:10px 12px}
    h3{margin:0;font-weight:700;letter-spacing:.4px}
    .pill{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid var(--border);color:var(--sub)}

    .kpi{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;padding:10px}
    .kpi .tile{background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:10px}
    .tile h4{margin:0 0 4px 0;color:var(--sub);font-size:12px;text-transform:uppercase;letter-spacing:.5px}
    .tile .v{font-size:22px;font-weight:700}

    .hand{display:flex;flex-wrap:wrap;gap:10px;padding:12px}
    .card{
      width:var(--cardW, clamp(64px, 22vw, 92px));
      aspect-ratio:var(--cardRatio);
      border-radius:12px;
      background-color:var(--card);
      background-size:cover;background-position:center;background-repeat:no-repeat;
      border:1px solid var(--border);
      position:relative;cursor:pointer;display:flex;align-items:center;justify-content:center;
      touch-action:manipulation;transition:transform .18s ease, background .18s ease;
    }
    .card:active{transform:translateY(1px)}
    .card:hover{background-color:var(--card-h)}
    .back{background-color:transparent;border:1px solid #1f2a3b}
    .card.selected{
      outline:3px solid var(--sel);
      outline-offset:2px;
      box-shadow:0 0 0 3px var(--sel), 0 10px 24px rgba(108,196,255,.20);
    }
    .card:focus-visible{
      outline:3px solid var(--sel);
      outline-offset:2px;
      box-shadow:0 0 0 3px var(--sel), 0 10px 24px rgba(108,196,255,.20);
    }

    .rank{
      position:absolute;bottom:8px;left:10px;font-weight:800;font-size:14px;line-height:1;
      padding:2px 6px;border-radius:8px;background:rgba(255,255,255,.95);color:#000;
      box-shadow:0 1px 0 rgba(0,0,0,.12);user-select:none;pointer-events:none
    }
    .tag{
      position:absolute;bottom:8px;right:10px;font-size:10px;padding:2px 6px;border:1px solid var(--border);
      border-radius:999px;color:var(--sub);background:#0e1622;user-select:none;pointer-events:none
    }

    .panel{padding:10px}
    #log{max-height:280px;overflow:auto;padding:10px;background:#0c121c;border-top:1px solid var(--border)}
    #log .line{opacity:.95}

    .drawer{
      position:fixed;left:0;right:0;bottom:0;max-height:75vh;background:var(--panel);
      border-top:1px solid var(--border);transform:translateY(105%);transition:.28s ease;
      display:flex;flex-direction:column;z-index:80;border-top-left-radius:16px;border-top-right-radius:16px;box-shadow:var(--shadow)
    }
    .drawer.open{transform:translateY(0)}
    .drawer header{background:var(--panel-2)}
    .drawer .body{padding:16px 12px;overflow:auto;padding-bottom:calc(12px + var(--safe-bottom))}
    .drawer .panel{padding-bottom:calc(10px + var(--safe-bottom))}
    .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}

    #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:calc(18px + 88px + var(--safe-bottom));display:flex;flex-direction:column;gap:8px;z-index:90}
    .toast{background:#0f1826;border:1px solid var(--border);padding:10px 12px;border-radius:12px;min-width:260px;text-align:center;opacity:1;transition:opacity .25s ease}
    .die{font-weight:800}

    .log-collapser{display:flex;justify-content:flex-end;padding:8px;background:#0c121c;border-top:1px solid var(--border)}
    .log-collapser button{padding:8px 10px;border-radius:999px}
    .log.is-collapsed{max-height:0;padding:0;border-top:none}

    .tabbar{
      position:fixed;left:0;right:0;bottom:0;background:rgba(10,15,23,.9);
      backdrop-filter:blur(10px);border-top:1px solid var(--border);
      padding:10px 12px calc(12px + var(--safe-bottom));z-index:50;
      transition:transform .25s ease, opacity .2s ease
    }
    .tabbar .tray{
  display:grid;
  grid-template-columns:repeat(7,1fr); /* was 6 */
  gap:10px;
}
    .tabbar button{padding:12px 8px;border-radius:12px}
    body.drawer-open .tabbar{transform:translateY(120%);opacity:0;pointer-events:none}

    button{background:#162232;color:var(--ink);border:1px solid var(--border);border-radius:12px;padding:12px 14px;cursor:pointer}
    button:disabled{opacity:.55;cursor:not-allowed}
    .btn-accent{border-color:#2b5aa1;background:#153055}
    .btn-warn{border-color:#7a4e14;background:#2a1b0a}
    .btn-ok{border-color:#1f6a4b;background:#0f2b1f}
    .btn-ghost{background:transparent}

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

    .no-anim *, .no-anim .card, .no-anim .drawer, .no-anim .toast { transition: none !important }

    @media (max-width: 899px){ .desktop-actions{ display:none } }
    @media (min-width: 900px){
      .wrap{grid-template-columns:280px 1fr 360px;max-width:1200px;padding:12px}
      .tabbar{display:none}
      .card{width:62px}
      #toast{bottom:18px}
      .drawer{left:auto;right:0;top:0;bottom:0;width:420px;max-height:none;border-radius:0;border-left:1px solid var(--border);border-top:none;transform:translateX(100%)}
      .drawer.open{transform:translateX(0)}
    }
    @media (prefers-reduced-motion: reduce){
      :root { scroll-behavior:auto }
      .drawer, .card, .toast { transition:none !important }
    }

    @keyframes dealIn { from{transform:translateY(12px) scale(.92);opacity:0} to{transform:none;opacity:1} }
    @keyframes pop { 0%{transform:scale(1)} 50%{transform:scale(1.06)} 100%{transform:scale(1)} }
    @keyframes bump { 0%{transform:translateY(0)} 35%{transform:translateY(-3px)} 100%{transform:translateY(0)} }
    @keyframes toastIn { from{transform:translate(-50%,12px);opacity:0} to{transform:translate(-50%,0);opacity:1} }
    @keyframes flash { from{background:#122033} to{background:transparent} }

    .anim-deal { animation:dealIn .28s ease forwards }
    .anim-pop { animation:pop .18s ease }
    .anim-bump { animation:bump .22s ease }
    .toast.anim-in { animation:toastIn .22s ease }
    #log .line.anim-flash { animation:flash .6s ease }

/* Suit-bonus banner */
#bannerHost{
  position:fixed; left:50%; transform:translateX(-50%);
  top:14px; z-index:95; display:flex; flex-direction:column; gap:10px;
}
.banner{
  background:#0f1826; border:1px solid var(--border);
  padding:12px 16px; border-radius:14px; min-width:280px;
  text-align:center; font-weight:700; letter-spacing:.3px;
  box-shadow:var(--shadow); opacity:1; animation:bannerIn .28s ease;
}
.banner .big{ font-size:18px; margin-bottom:2px }
.banner .sub{ font-size:12px; color:var(--sub) }
.banner.club { border-color:#2d5a2d; background:#0f1f12 }
.banner.diamond { border-color:#6a4a0e; background:#1f160a }
.banner.spade { border-color:#2b3550; background:#0d1320 }
.banner.heart { border-color:#613344; background:#1a0f15 }
@keyframes bannerIn { from{transform:translate(-50%,-8px); opacity:0} to{transform:translate(-50%,0); opacity:1} }

/* Tutorial overlay */
#tutorialDrawer .step{ display:none }
#tutorialDrawer .step.active{ display:block }
#tutorialDots{ display:flex; gap:6px; align-items:center }
#tutorialDots .dot{
  width:8px; height:8px; border-radius:999px; background:#263243; border:1px solid var(--border)
}
#tutorialDots .dot.on{ background:#6cc4ff; }
    /* Card rank tooltips */
.card .rank[data-tip]{ position:relative; cursor:help }
.card .rank[data-tip]:focus::after,
.card .rank[data-tip]:hover::after{
  content: attr(data-tip);
  position:absolute; left:0; bottom:120%;
  background:#0f1826; color:var(--ink);
  border:1px solid var(--border); border-radius:8px;
  padding:6px 8px; font-size:11px; white-space:nowrap; z-index:10;
  box-shadow:var(--shadow);
}
    /* Construct preview bar */
#constructPreview{
  position:sticky; bottom:0; left:0; right:0;
  margin:8px 10px; padding:10px 12px;
  background:#0e1622; border:1px solid var(--border);
  border-radius:12px; color:var(--ink); display:none;
  align-items:center; justify-content:space-between; gap:10px;
}
#constructPreview .left{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
#constructPreview .pill{ background:#0d1522; }
.preview-good{ color:var(--ok) }
.preview-bad{ color:var(--bad) }
.card.selected.preview-glow{
  box-shadow:0 0 0 3px var(--sel), 0 12px 26px rgba(108,196,255,.28);
}
    /* iOS bottom padding guard */
    @supports(padding:max(0px)) {
      .tabbar { padding-bottom: max(12px, var(--safe-bottom)); }
    }
  </style>
</head>
<body>
  <a class="sr-only" href="#main">Skip to content</a>

  <div class="wrap" id="main">
    <!-- Left column -->
    <div class="col" id="leftCol">
      <header class="sticky bar">
        <div style="display:flex;align-items:center;gap:8px">
          <button id="btnSettings" title="Settings" class="btn-ghost" aria-label="Open settings">‚öôÔ∏è</button>
          <h3>Arcana ‚Äî Solo / Online</h3>
        </div>
        <span class="pill" id="turnTag" aria-live="polite">‚Äî</span>
      </header>

      <div class="kpi" role="region" aria-label="Scoreboard">
        <div class="tile"><h4>You</h4><div class="v" id="scoreYou">0</div></div>
        <div class="tile"><h4>Opponent</h4><div class="v" id="scoreAI">0</div></div>
        <div class="tile"><h4>Deck</h4><div class="v" id="deckTag">‚Äî</div></div>
        <div class="tile"><h4>Discard</h4><div class="v" id="discardTag">‚Äî</div></div>
      </div>

      <div class="panel desktop-actions">
        <div class="row" style="display:flex;gap:10px;flex-wrap:wrap">
          <button id="btnStart" class="btn-ok">‚ñ∂Ô∏è Start</button>
          <button id="btnRules" class="btn-accent" aria-controls="rulesDrawer">üìú Rules</button> 
          <button id="btnTutorial" class="btn-accent">‚ùî Tutorial</button>
          <button id="btnConstruct">üß© Construct</button>
          <button id="btnAction">üéØ Action (6/7/9)</button>
          <button id="btnSigil">‚ú® Sigil (J/Q/K)</button>
          <button id="btnDiscard" class="btn-warn">üóëÔ∏è Discard (+1)</button>
        </div>
      </div>
    </div>

    <!-- Middle column: hands -->
    <div class="col" aria-label="Hands">
      <header class="sticky bar">
        <h3>Your Hand</h3>
        <span class="pill"><span id="youCount">0</span> cards</span>
      </header>
      <div id="yourHand" class="hand" aria-live="polite"></div>

      <header class="bar">
        <h3>Opponent Hand</h3>
        <span class="pill"><span id="aiCount">0</span> cards</span>
      </header>
      <div id="aiHand" class="hand"></div>
    </div>

<div id="constructPreview" aria-live="polite">
  <div class="left">
    <span id="previewKind" class="pill">‚Äî</span>
    <span id="previewPoints" class="preview-good">‚Äî</span>
    <span id="previewExtras" class="pill" style="display:none"></span>
    <span id="previewWhy" class="preview-bad" style="display:none"></span>
  </div>
  <button id="previewPlay" class="btn-ok" style="display:none">Play Construct</button>
</div>
    
    <!-- Right column: Log -->
    <div class="col">
      <header class="sticky bar">
        <h3>Activity</h3>
        <span class="pill" id="modeTag">‚Äî</span>
      </header>
      <div class="log-collapser"><button id="toggleLog" aria-expanded="true">Hide activity</button></div>
      <div id="log" class="log" role="log" aria-live="polite"></div>
    </div>
  </div>

  <!-- Bottom Tabbar (mobile only) -->
  <nav class="tabbar" aria-label="Arcana actions">
    <div class="tray">
      <button id="mbStart" class="btn-ok" aria-label="Start New">‚ñ∂Ô∏è Start</button>
      <button id="mbConstruct" aria-label="Play Construct">üß© Construct</button>
      <button id="mbAction" aria-label="Play Action">üéØ Action</button>
      <button id="mbSigil" aria-label="Play Sigil">‚ú® Sigil</button>
      <button id="mbDiscard" class="btn-warn" aria-label="Discard">üóëÔ∏è Discard</button>
      <button id="mbRules" class="btn-accent" aria-label="Rules">üìú Rules</button>
      <button id="mbTutorial" class="btn-accent" aria-label="Tutorial">‚ùî Tutorial</button>
    </div>
  </nav>

  <!-- Drawers / Sheets -->
  <div class="drawer" id="giveDrawer" aria-label="Choose a card to give" aria-hidden="true">
    <header class="bar"><h3 style="margin:0">Swap ‚Äî Choose one card to give</h3></header>
    <div class="body"><div id="giveGrid" class="grid"></div></div>
    <div class="panel" style="display:flex;justify-content:flex-end;gap:8px">
      <button id="giveCancel">Cancel</button>
    </div>
  </div>

  <div class="drawer" id="payDrawer" aria-label="Pay Page cost" aria-hidden="true">
    <header class="bar"><h3 style="margin:0">Pay Page Cost</h3></header>
    <div class="body">
      <p id="payHint" style="margin-top:0;color:var(--sub)"></p>
      <div id="payGrid" class="grid"></div>
    </div>
    <div class="panel" style="display:flex;justify-content:flex-end;gap:8px">
      <button id="payCancel">Cancel</button>
      <button id="payConfirm" class="btn-ok" disabled>Pay & Play</button>
    </div>
  </div>

  <div class="drawer" id="aceDrawer" aria-label="Ace reaction" aria-hidden="true">
    <header class="bar"><h3 style="margin:0">React with Ace?</h3></header>
    <div class="body">
      <p id="acePrompt" style="margin-top:0;color:var(--sub)"></p>
      <div class="row" style="display:flex;gap:10px;flex-wrap:wrap">
        <button id="aceYes" class="btn-ok">üõ°Ô∏è Block (roll d6)</button>
        <button id="aceNo" class="btn-warn">Let it resolve</button>
      </div>
      <p style="margin:.5rem 0 0 0;font-size:12px;color:var(--sub)">
        On 7/9: 1‚Äì3 fail (action proceeds), 4‚Äì6 block + counter +1. On Sigil: discard 2 Aces to auto-block.
      </p>
    </div>
  </div>

  <div class="drawer" id="sigilDrawer" aria-label="Play a Sigil" aria-hidden="true">
    <header class="bar"><h3 style="margin:0">Play Sigil</h3></header>
    <div class="body">
      <p id="sigilHint" style="margin-top:0;color:var(--sub)"></p>
      <div class="row" style="display:flex;gap:10px;flex-wrap:wrap">
        <button id="sigilPoints" class="btn-ok">Score Points</button>
        <button id="sigilDraw"  class="btn-accent">Draw Cards</button>
        <button id="sigilCancel" class="btn-ghost">Cancel</button>
      </div>
    </div>
  </div>

  <div class="drawer" id="rulesDrawer" aria-label="Rules" aria-modal="true" role="dialog" aria-hidden="true">
    <header class="bar" style="display:flex;align-items:center;justify-content:space-between">
      <h3 style="margin:0">Rules</h3>
      <button id="rulesClose" aria-label="Close rules">Close</button>
    </header>
    <div class="body" style="font-size:14px;color:var(--sub)">
      <div style="display:grid;gap:10px">
        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üéØ Goal</h4>
          <p style="margin:0">Reach <strong>60 points</strong> before your opponent.</p>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üîÑ Turn Flow</h4>
          <ul style="margin:0 0 0 1rem;padding:0">
            <li>End of your turn: <strong>draw 1</strong>.</li>
            <li>If you start a turn with ‚â§ 1 card: <strong>draw 3</strong> (safety).</li>
            <li>New game: deal 7 each. P1 starts.</li>
          </ul>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üß© Constructs (score to discard pile)</h4>
          <div style="display:grid;gap:8px">
            <div>
              <strong>Pairs</strong>
              <ul style="margin:4px 0 0 1rem;padding:0">
                <li><strong>Pair</strong> (2 of same rank): <strong>2</strong> pts</li>
                <li><strong>True Pair</strong> (same rank + same suit): <strong>5</strong> pts</li>
              </ul>
            </div>

    
            <div>
              <strong>Sets</strong> (3+ of the same rank)
              <ul style="margin:4px 0 0 1rem;padding:0">
                <li>3 cards: <code>2 √ó rank + 2</code> pts</li>
                <li>4 cards: if all four suits present ‚Üí <code>4 √ó rank</code>, else <code>3 √ó rank</code></li>
                <li>5+ cards: <code>3 √ó rank + 2</code> pts</li>
                <li><em>Suit bonus</em> applies if all non-Page cards are the same suit (see Suit Bonuses). With Pages, suit bonus only applies if size ‚â• 5.</li>
              </ul>
            </div>
            <div>
              <strong>Runs</strong> (3+ in sequence, same suit)
              <ul style="margin:4px 0 0 1rem;padding:0">
                <li>Score = sum of ranks + <code>+1</code> per card</li>
                <li>Pages (Jokers) can fill gaps; if any Page is used: <strong>no suit bonus</strong> and <strong>‚àí1 point per Page</strong></li>
              </ul>
            </div>
            <div>
              <strong>Using Pages (Jokers)</strong> in any non‚ÄìPage-only construct
              <ul style="margin:4px 0 0 1rem;padding:0">
                <li>For each Page used: discard <strong>one extra</strong> other card (Page cost)</li>
                <li>
  For each Page used: total points get <strong>‚àí1</strong>
  <span style="color:var(--sub);font-size:12px">(shown in activity log &amp; preview)</span>
</li>
              </ul>
            </div>
            <div>
              <strong>Page-only plays</strong> (discard these Pages to score)
              <ul style="margin:4px 0 0 1rem;padding:0">
                <li>2 Pages ‚Üí <strong>4</strong> pts</li>
                <li>3 Pages ‚Üí <strong>7</strong> pts and <strong>draw 3</strong></li>
                <li>4 Pages ‚Üí <strong>15</strong> pts and <strong>refill hand to 7</strong></li>
              </ul>
            </div>
          </div>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">‚ô• ‚ô£ ‚ô¶ ‚ô† Suit Bonuses</h4>
          <ul style="margin:0 0 0 1rem;padding:0">
            <li><strong>‚ô• Hearts</strong>: +3 pts</li>
            <li><strong>‚ô£ Clubs</strong>: take an extra turn (cap 2 in a row)</li>
            <li><strong>‚ô¶ Diamonds</strong>: roll d6 ‚Üí steal <strong>1/2/3</strong> points from opponent‚Äôs score</li>
            <li><strong>‚ô† Spades</strong>: steal up to <strong>2 random cards</strong> from opponent‚Äôs hand</li>
          </ul>
          <p style="margin:6px 0 0 0;font-size:12px;opacity:.9">Suit bonus applies to Constructs where all non-Page cards share that suit (see Pages notes under Sets/Runs).</p>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üé≠ Actions (6 / 7 / 9)</h4>
          <ul style="margin:0 0 0 1rem;padding:0">
            <li><strong>6</strong>: Draw 2</li>
            <li><strong>7</strong>: Steal 1 random card (Ace can attempt to block)</li>
            <li><strong>9</strong>: Swap ‚Äî give 1, take 1 (Ace can attempt to block)
              <ul style="margin:4px 0 0 1rem;padding:0">
                <li>If 9 is blocked: your ‚Äúgive‚Äù card is discarded</li>
                <li>If 9 is not blocked: your ‚Äúgive‚Äù card goes to the defender</li>
              </ul>
            </li>
          </ul>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üÇ± Aces (Defense & Counter)</h4>
          <ul style="margin:0 0 0 1rem;padding:0">
            <li>Against <strong>7/9</strong>: roll d6 ‚Üí <strong>1‚Äì3 fail</strong> (action proceeds), <strong>4‚Äì6 block</strong> and you gain <strong>+1</strong> point</li>
            <li>Against a <strong>Sigil</strong>: discard <strong>2 Aces</strong> to auto-block (Sigil is discarded)</li>
          </ul>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üëë Sigils (J / Q / K)</h4>
          <ul style="margin:0 0 0 1rem;padding:0">
            <li><strong>Points</strong>: J +1, Q +2, K +3</li>
            <li><strong>Draw</strong>: J/Q +1, K +2</li>
            <li>Opponent may auto-block by discarding <strong>2 Aces</strong></li>
          </ul>
        </section>

        <section style="background:#0e1622;border:1px solid var(--border);border-radius:12px;padding:12px">
          <h4 style="margin:0 0 6px 0;color:var(--ink)">üì¶ Discard</h4>
          <p style="margin:0">Discard any 1 card to gain <strong>+1 point</strong>.</p>
        </section>
      </div>
    </div>
  </div>
  
<div class="drawer" id="tutorialDrawer" aria-label="Tutorial" aria-hidden="true" role="dialog" aria-modal="true">
  <header class="bar" style="display:flex;align-items:center;justify-content:space-between">
    <h3 style="margin:0">How to Play</h3>
    <div id="tutorialDots" aria-hidden="true">
      <div class="dot on"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>
    <button id="tutorialClose" aria-label="Close tutorial">Close</button>
  </header>
  <div class="body" style="font-size:14px;color:var(--sub)">
    <div class="step active">
      <h4 style="margin:0 0 6px 0;color:var(--ink)">1) Build Constructs for points</h4>
      <p>Make Pairs, Sets, or Runs. Pages (Jokers) can help, but may cost points and extra discards.</p>
    </div>
    <div class="step">
      <h4 style="margin:0 0 6px 0;color:var(--ink)">2) Actions (6/7/9)</h4>
      <p>6 draws 2. 7 steals 1 (Ace can try to block). 9 swaps a card (Ace can try to block).</p>
    </div>
    <div class="step">
      <h4 style="margin:0 0 6px 0;color:var(--ink)">3) Sigils (J/Q/K)</h4>
      <p>Choose Points (J+1/Q+2/K+3) or Draw (J/Q +1, K +2). Opponent can auto-block by discarding 2 Aces.</p>
    </div>
    <div class="step">
      <h4 style="margin:0 0 6px 0;color:var(--ink)">4) Suit bonuses</h4>
      <p>One-suit Constructs (no Pages) gain bonuses: ‚ô• +3 ‚Ä¢ ‚ô£ extra turn ‚Ä¢ ‚ô¶ steal points ‚Ä¢ ‚ô† steal up to 2 cards.</p>
    </div>

    <div class="panel" style="display:flex;justify-content:space-between;gap:8px;margin-top:10px">
      <label style="display:flex;align-items:center;gap:6px">
        <input type="checkbox" id="tutorialDontShow"> Don‚Äôt show again
      </label>
      <div style="display:flex;gap:8px">
        <button id="tutorialPrev">Back</button>
        <button id="tutorialNext" class="btn-ok">Next</button>
      </div>
    </div>
  </div>
</div>

  <!-- Settings Drawer -->
  <div class="drawer" id="settingsDrawer" aria-label="Settings" aria-hidden="true">
    <header class="bar" style="display:flex;align-items:center;justify-content:space-between">
      <h3 style="margin:0">Settings</h3>
      <button id="settingsClose" aria-label="Close settings">Close</button>
    </header>
    <div class="body" style="font-size:14px;color:var(--sub)">
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <label><input type="checkbox" id="optHaptics"> Haptics</label>
        <label><input type="checkbox" id="optAnims" checked> Animations</label>
        <label><input type="checkbox" id="optSwipe"> Swipe-to-discard</label>

        <label>Card size
          <select id="optCardSize">
            <option value="auto">Auto</option>
            <option value="compact">Compact</option>
            <option value="large">Large</option>
          </select>
        </label>

        <label>AI
          <select id="optAI">
            <option value="none">None (Online)</option>
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
            <option value="expert">Expert</option>
          </select>
        </label>

        <label>Mode
          <select id="optMode">
            <option value="solo" selected>Solo vs AI</option>
            <option value="online">Online Multiplayer</option>
          </select>
        </label>

        <label>Role
          <select id="optRole">
            <option value="host" selected>Host (P1)</option>
            <option value="guest">Guest (P2)</option>
          </select>
        </label>

        <label>Room / Host ID
          <input id="optRoom" placeholder="e.g. my-room-123" />
        </label>

        <div style="grid-column:1 / -1; display:flex; gap:8px; flex-wrap:wrap">
          <button id="btnConnect" class="btn-ok">üîå Connect</button>
          <button id="btnDisconnect" class="btn-warn">‚ùå Disconnect</button>
          <span id="netStatus" class="pill">Offline</span>
        </div>
      </div>

      <div class="panel" style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px">
        <button id="resetGame" class="btn-warn">Reset game</button>
      </div>
    </div>
  </div>

  <!-- Toast region -->
  <div id="toast" role="status" aria-live="polite" aria-atomic="true"></div>

<div id="bannerHost" aria-live="polite" aria-atomic="true"></div>
  
  <!-- === GAME LOGIC + ONLINE SYNC === -->
  <script>
    "use strict";
    
  const $ = (id)=>document.getElementById(id);
  const SUITS=['‚ô†','‚ô•','‚ô¶','‚ô£'];
  const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const RVAL=r=>({A:1,J:11,Q:12,K:13}[r]||parseInt(r,10));
  const isPage=c=>c.page===true;
  const isJQK=r=>r==='J'||r==='Q'||r==='K';
  const rnd=n=>Math.floor(Math.random()*n);

  const IMG_BASE="cards/";
  const EXT=".webp";

function suitSlug(s){
  return s==='‚ô•' ? 'hearts'
       : s==='‚ô¶' ? 'diamonds'
       : s==='‚ô£' ? 'clubs'
       :          'spades';
}
  function rankSlug(r){
    if (r==='A') return 'ace';
    if (r==='J') return 'j';
    if (r==='Q') return 'q';
    if (r==='K') return 'k';
    return r;
  }
  function imgPath(c){
    if (c.back) return IMG_BASE + "back" + EXT;
    if (isPage(c)) return IMG_BASE + `page ${c.pageIndex}` + EXT;
return IMG_BASE + `${rankSlug(c.rank)} ${suitSlug(c.suit)}` + EXT;
  }

  // Prefs & save
  const PREF_KEY='arcana_prefs_v2';
  const SAVE_KEY='arcana_state_v1';
  const Pref={haptics:false, anims:true, swipe:false, cardSize:'auto', ai:'normal', mode:'solo', role:'host', room:''};
  function loadPrefs(){try{const p=JSON.parse(localStorage.getItem(PREF_KEY)); if(p) Object.assign(Pref,p);}catch{}}
  function savePrefs(){try{localStorage.setItem(PREF_KEY,JSON.stringify(Pref));}catch{}}

  const PREFERS_REDUCED_MOTION =
  !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
  function buzz(ms=20){try{ if(PREFERS_REDUCED_MOTION) return; Pref.haptics && navigator.vibrate && navigator.vibrate(ms);}catch{}}

  // Toasts (with cap)
  function toast(html,ms=1650){
    const host=$('toast');
    while(host.children.length>4) host.firstChild.remove();
    const t=document.createElement('div');
    t.className='toast anim-in'; t.innerHTML=html;
    host.appendChild(t);
    setTimeout(()=>{t.style.opacity='0'; setTimeout(()=>t.remove(),320);},ms);
  }
  function toastSafe(text,ms=1650){
    const host=$('toast');
    while(host.children.length>4) host.firstChild.remove();
    const t=document.createElement('div');
    t.className='toast anim-in'; t.textContent=text;
    host.appendChild(t);
    setTimeout(()=>{t.style.opacity='0'; setTimeout(()=>t.remove(),320);},ms);
  }
function banner(html, cls='', ms=2200){
  const host = $('bannerHost');
  const b = document.createElement('div');
  b.className = `banner ${cls}`;
  b.innerHTML = html;
  host.appendChild(b);
  setTimeout(()=>{ b.style.opacity='0'; b.style.transition='opacity .25s';
    setTimeout(()=>b.remove(), 300);
  }, ms);
}
function suitBanner(suit, extra=''){
  const map = { '‚ô•':['heart','‚ô• Hearts +3'], '‚ô£':['club','‚ô£ Extra turn'], '‚ô¶':['diamond','‚ô¶ Steal points'], '‚ô†':['spade','‚ô† Steal up to 2 cards'] };
  const [cls, title] = map[suit] || ['','Suit bonus'];
  banner(`<div class="big">${title}</div><div class="sub">${extra}</div>`, cls);
}
  // Anim helpers
  function addAnim(el,cls,ms=400){
    if(!el || !Pref.anims || document.body.classList.contains('no-anim')) return;
    el.classList.add(cls);
    const kill=()=>el.classList.remove(cls);
    el.addEventListener('animationend',kill,{once:true});
    setTimeout(kill,ms+50);
  }
  function bumpScore(pid){
    const id=(pid===myPid())?'scoreYou':'scoreAI';
    const el=$(id); addAnim(el,'anim-bump',240);
  }
  function flashLogLast(){
    const logEl=$('log'); if(!logEl) return;
    const last=logEl.lastElementChild; if(last) addAnim(last,'anim-flash',600);
  }

  // Drawer helpers: focus, aria-hidden, ESC to close
  function markDrawerState(){const anyOpen=!!document.querySelector('.drawer.open');document.body.classList.toggle('drawer-open', anyOpen);}
  function openDrawer(el){
    el.classList.add('open');
    document.querySelectorAll('.drawer').forEach(d=>{
      const active = d===el && d.classList.contains('open');
      d.setAttribute('aria-hidden', String(!active));
    });
    markDrawerState();
    const first = el.querySelector('button, [href], [tabindex]:not([tabindex="-1"])');
    if (first) first.focus();
  }
  function closeDrawer(el){
    el.classList.remove('open');
    el.setAttribute('aria-hidden','true');
    markDrawerState();
  }
  document.addEventListener('keydown',(e)=>{
    if(e.key==='Escape'){
      const open=document.querySelector('.drawer.open');
      if(open){ e.preventDefault(); closeDrawer(open); }
    }
  });

  // === STATE SERIALIZATION (with masking) ===
  function serialize(){
    return JSON.stringify({deck:G.deck,discard:G.discard,players:G.players,turn:G.turn,started:G.started,clubChain:G.clubChain});
  }
  function serializeFor(viewerPid){
    const maskHand=(h)=>h.map(_=>({back:true}));
    const players=[
      (viewerPid===0? {hand:[...G.players[0].hand],score:G.players[0].score}
                    : {hand:maskHand(G.players[0].hand),score:G.players[0].score}),
      (viewerPid===1? {hand:[...G.players[1].hand],score:G.players[1].score}
                    : {hand:maskHand(G.players[1].hand),score:G.players[1].score})
    ];
    const deckLensafe=Array(G.deck.length).fill({back:true});
    return JSON.stringify({ deck:deckLensafe, discard:[...G.discard], players, turn:G.turn, started:G.started, clubChain:G.clubChain });
  }
  function deserialize(s){try{const o=JSON.parse(s); if(!o||!Array.isArray(o.deck)) return null; return o;}catch{return null;}}

  // Network
  const Net={
    ws:null, connected:false, hostId:null, connecting:false,
    isOnline(){return Pref.mode==='online' && this.connected;},
    connect(){
      if(this.connected||this.connecting) return;
      this.connecting=true;
      try{ if (this.ws) this.ws.close() }catch{}
      const url=(location.protocol==='https:'?'wss':'ws')+'://arcana-signal.onrender.com';
      this.ws=new WebSocket(url);
      this.ws.onopen=()=>{
        this.connected=true; this.connecting=false;
        $('netStatus').textContent='Connected';
        if(Pref.role==='host'){
          this.hostId=Pref.room || ('room-'+Math.random().toString(36).slice(2,8));
          send({type:'host',hostId:this.hostId});
          toastSafe(`Room: ${this.hostId}`); log(`Hosting room: ${this.hostId}`);
        }else{
          this.hostId=Pref.room;
          if(!this.hostId){ log('Enter a Room/Host ID, then Connect.'); return; }
          send({type:'join',hostId:this.hostId});
          toastSafe(`Joining: ${this.hostId}`); log(`Joining room: ${this.hostId}`);
        }
        updateModeTag(); updateStartDisabled();
      };
      this.ws.onclose=()=>{
        this.connected=false; this.connecting=false; $('netStatus').textContent='Offline';
        updateModeTag(); updateStartDisabled();
      };
      this.ws.onmessage=(ev)=>{
        let m={}; try{m=JSON.parse(ev.data);}catch{return;}
        if(m.type==='host-ok'){ toastSafe(`Room ready: ${m.hostId}`) }
        if(m.type==='join-ok'){ toastSafe(`Joined: ${m.hostId}`) }
        if(m.type==='guest-joined'){ toast('Guest joined.'); if(Pref.role==='host'){ sendSync(1) } }
        if(m.type==='guest-left'){ toast('Guest left.') }
        if(m.type==='host-left'){ toast('Host left.') }
        if(m.type==='host-error'){ toastSafe(`Host error: ${m.reason||'unknown'}`) }
        if(m.type==='join-error'){ toastSafe(`Join failed: ${m.reason||'host-not-found'}`) }
        if(m.type==='signal' && m.payload){ onSignal(m.payload) }
      };
      function send(obj){ try{ Net.ws && Net.ws.readyState===1 && Net.ws.send(JSON.stringify(obj)) }catch{} }
      Net._sendRaw=send;
    },
    disconnect(){ try{ if (this.ws) this.ws.close() }catch{}; this.ws=null; this.connected=false; this.connecting=false; $('netStatus').textContent='Offline'; updateModeTag(); updateStartDisabled(); },
  };
  function sendSig(payload){ if(Net.ws && Net.ws.readyState===1){ Net._sendRaw({type:'signal', hostId:Net.hostId, payload}) } }
  function sendSync(toPid){
    const state=(Pref.role==='host') ? serializeFor(toPid) : serialize();
    sendSig({kind:'SYNC', state});
  }

  // Game state
  const G={deck:[],discard:[],players:[{hand:[],score:0},{hand:[],score:0}],turn:0,started:false,selected:new Set(),chooseGive:null,aceQuery:null,clubChain:0};
  const Prev={handCounts:[0,0]};
const Telemetry = {
  player: {
    actions: 0, sigils: 0, constructs: 0, discards: 0,
    blocksByAce: 0,
    lastTurnType: null, // 'action'|'sigil'|'construct'|'discard'
  },
  turnsSincePlayerAction: 0
};
// --- START PATCH: Telemetry helper functions ---
function markPlayerTurn(kind){
  // kind: 'action' | 'sigil' | 'construct' | 'discard'
  Telemetry.player.lastTurnType = kind;
  if (kind === 'action') Telemetry.turnsSincePlayerAction = 0;
  else Telemetry.turnsSincePlayerAction++;
}
function notePlayerAceBlockSuccess(){
  Telemetry.player.blocksByAce++;
}
// --- END PATCH ---
  function buildDeck(){
    const cards=[]; let id=1;
    for(let copies=0; copies<2; copies++){
      for(const s of SUITS){ for(const r of RANKS){ cards.push({id:id++,suit:s,rank:r}) } }
    }
    for(let i=1;i<=4;i++){ cards.push({id:id++,page:true,rank:'Page',suit:'',pageIndex:i}) }
    shuffle(cards); return cards;
  }
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=rnd(i+1);[a[i],a[j]]=[a[j],a[i]]}}

  function saveState(){ if(Pref.mode==='online' && Pref.role==='guest') return; try{localStorage.setItem(SAVE_KEY,serialize())}catch{} }
  function loadState(){const raw=localStorage.getItem(SAVE_KEY);const o=deserialize(raw);if(!o) return false;Object.assign(G,o);Prev.handCounts=[G.players[0].hand.length,G.players[1].hand.length];return true}

  function myPid(){ return (Pref.mode==='online' ? (Pref.role==='host'?0:1) : 0) }

  // DRAW / RECYCLE
  function recycleIfNeeded(){
    if(G.deck.length===0 && G.discard.length>0){
      G.deck.push(...G.discard.splice(0,G.discard.length));
      shuffle(G.deck);
      log('Deck reshuffled.');
    }
  }
  function draw(pid,n){
    for(let i=0;i<n;i++){
      if(G.deck.length===0) recycleIfNeeded();
      if(G.deck.length===0) break;
      G.players[pid].hand.push(G.deck.pop());
    }
  }
  function endOfTurnDraw(pid){ draw(pid,1) }
function ensureMyTurnUI(){
  const myTurn = G.started && (G.turn === myPid());
  const ids = ['btnAction','btnSigil','btnConstruct','btnDiscard','mbAction','mbSigil','mbConstruct','mbDiscard'];
  ids.forEach(id => {
    const el = $(id); if(!el) return;
    el.disabled = !myTurn;
    el.setAttribute('aria-disabled', String(!myTurn));
  });
}
  function render(){
    $('deckTag').textContent=G.deck.length; $('discardTag').textContent=G.discard.length;
    $('scoreYou').textContent=G.players[myPid()].score; $('scoreAI').textContent=G.players[1-myPid()].score;
    $('turnTag').textContent=G.started?(G.turn===myPid()?'Your turn':(Pref.mode==='online'?'Their turn':(G.turn===0?'Your turn':'AI turn'))):'‚Äî';
    $('modeTag').textContent = Pref.mode==='online' ? (Pref.role.toUpperCase() + ' ‚Ä¢ ' + (Net.connected?'ONLINE':'OFFLINE')) : ('SOLO ‚Ä¢ ' + Pref.ai.toUpperCase());
updateConstructPreview();
    const yh=$('yourHand'), ah=$('aiHand'); yh.innerHTML=''; ah.innerHTML='';
    // Your hand (fronts)
    G.players[myPid()].hand.forEach((c)=>{
      const n=cardNode(c,true);
      n.tabIndex=0;
      n.onkeydown=(e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggleSelect(c.id,n) } };
      if(G.selected.has(c.id)) n.classList.add('selected');

      let pressTimer=null, wasLong=false, startX=null;
      n.onpointerdown=(e)=>{ wasLong=false; startX=e.clientX; pressTimer=setTimeout(()=>{wasLong=true; toggleSelect(c.id,n); buzz(12); addAnim(n,'anim-pop',180)},220) };
      n.onpointerup=(e)=>{ clearTimeout(pressTimer);
        const swiped=(Pref.swipe && startX!=null && Math.abs(e.clientX-startX)>90);
        if(swiped && G.turn===myPid()){ G.selected.clear(); G.selected.add(c.id); userAction({type:'DISCARD',pid:myPid(),cardId:c.id}) }
        else if(!wasLong){ toggleSelect(c.id,n); buzz(8); addAnim(n,'anim-pop',180) }
        startX=null;
      };
      n.onpointercancel=n.onpointerleave=()=>{ clearTimeout(pressTimer); startX=null };
      yh.appendChild(n);
    });
    $('youCount').textContent=G.players[myPid()].hand.length;

    // Opponent hand (backs)
    G.players[1-myPid()].hand.forEach(_=>{
      const d=cardNode({back:true},false);
      ah.appendChild(d);
    });
    $('aiCount').textContent=G.players[1-myPid()].hand.length;

    // Deal-in animations on count increase
    const cur0=G.players[0].hand.length, cur1=G.players[1].hand.length;
    if(cur0>Prev.handCounts[0] && myPid()===0){ const last=yh.lastElementChild; if(last) addAnim(last,'anim-deal',280) }
    if(cur1>Prev.handCounts[1] && myPid()===1){ const last=yh.lastElementChild; if(last) addAnim(last,'anim-deal',280) }
    if(cur0>Prev.handCounts[0] && myPid()===1){ const last=ah.lastElementChild; if(last) addAnim(last,'anim-deal',280) }
    if(cur1>Prev.handCounts[1] && myPid()===0){ const last=ah.lastElementChild; if(last) addAnim(last,'anim-deal',280) }
    Prev.handCounts=[cur0,cur1];

    // Buttons
const myTurn = G.started && (G.turn === myPid());
if (!myTurn && G.selected.size) G.selected.clear(); // prevent ghost selections across turns
ensureMyTurnUI();
updateStartDisabled();
  }
  function updateStartDisabled(){
    const shouldDisableStart=(Pref.mode==='online' && Pref.role!=='host');
    ['btnStart','mbStart'].forEach(id=>{ const el=$(id); if(el){ el.disabled=shouldDisableStart; el.setAttribute('aria-disabled', String(shouldDisableStart)) }})
  }

  function cardNode(c,show){
    const d=document.createElement('div');
    d.className='card';
    const t=typeOf(c);

    if(show){
      d.style.backgroundImage=`url("${imgPath(c)}")`;

      if(!isPage(c)){
  const chip=document.createElement('div');
  chip.className='rank';
  chip.textContent = (c.rank ?? '') + (c.suit ?? '');
  chip.setAttribute('data-tip', rankTip(c));
  chip.tabIndex = 0; // focus = tooltip on keyboard
  d.appendChild(chip);
}
      if(t==='Page'){
        const tag=document.createElement('div');
        tag.className='tag';
        tag.textContent=t;
        d.appendChild(tag);
      }
      // Accessible name & state
      const suitWord = isPage(c) ? '' : suitSlug(c.suit);
      d.setAttribute('role','button');
      d.setAttribute('aria-label', isPage(c) ? 'Page (Joker)' : `${c.rank} of ${suitWord}`);
      d.setAttribute('aria-pressed', G.selected.has(c.id)?'true':'false');
    } else {
      d.classList.add('back');
      d.style.backgroundImage=`url("${IMG_BASE}back${EXT}")`;
      d.setAttribute('aria-hidden','true');
    }
    return d;
  }

  function toggleSelect(id,node){
    if(G.turn!==myPid()) return;
    const on=G.selected.has(id);
    if(on){ G.selected.delete(id); node.classList.remove('selected'); node.setAttribute('aria-pressed','false') }
    else { G.selected.add(id); node.classList.add('selected'); node.setAttribute('aria-pressed','true') }
updateConstructPreview();  
}
  function typeOf(c){
    if(isPage(c)) return 'Page';
    if(isJQK(c.rank)) return 'Sigil';
    if(c.rank==='A') return 'Ace';
    if(c.rank==='6'||c.rank==='7'||c.rank==='9') return 'Action';
    return 'Normal';
  }

  function startNew(){
    G.deck=buildDeck(); G.discard=[]; G.players=[{hand:[],score:0},{hand:[],score:0}];
    G.turn=0; G.started=true; G.selected.clear(); G.clubChain=0;
    draw(0,7); draw(1,7); log('New game. P1 starts.');

// --- START PATCH: reset Telemetry on new game ---
Telemetry.player.actions = 0;
Telemetry.player.sigils = 0;
Telemetry.player.constructs = 0;
Telemetry.player.discards = 0;
Telemetry.player.blocksByAce = 0;
Telemetry.player.lastTurnType = null;
Telemetry.turnsSincePlayerAction = 0;
// --- END PATCH ---

render(); maybeSafetyDraw(); saveState();
  }
  function discardFromHandById(pid,id){
    const h=G.players[pid].hand; const i=h.findIndex(c=>c.id===id);
    if(i<0) return null; const c=h.splice(i,1)[0]; G.discard.push(c); return c;
  }
  function takeFromHandById(pid,id){
    const h=G.players[pid].hand; const i=h.findIndex(c=>c.id===id);
    if(i<0) return null; return h.splice(i,1)[0];
  }
  function removeFromHandByIds(pid,ids){
    const h=G.players[pid].hand, out=[];
    ids.forEach(id=>{const i=h.findIndex(c=>c.id===id); if(i>=0) out.push(h.splice(i,1)[0])});
    return out;
  }
  function endTurn(){
  // draw for the player whose turn just ended
  draw(G.turn, 1);

  // advance turn and clean transient state
  G.turn = 1 - G.turn;
  G.selected.clear();
  G.clubChain = 0;
  G.aceQuery = null;   // clear any stale ace prompts
  G.chooseGive = null; // clear any stale 9-give modal

  render();
  ensureMyTurnUI();
  maybeSafetyDraw();
  saveState();

  if (G.started && Pref.mode === 'solo' && G.turn === 1) setTimeout(aiTakeTurn, 380);
  if (Net.isOnline() && Pref.role === 'host') sendSync(1);

  }
  function maybeSafetyDraw(){ if(!G.started) return; const pid=G.turn; if(G.players[pid].hand.length<=1){ draw(pid,3); log(`${pid===0?'P1':'P2'} drew 3 (safety).`); render() } }

  function validateConstruct(cards){
    const res={valid:false,kind:'',points:0,suit:null,jokersUsed:0,suitBonus:null,reason:''}; 
    res.pagePenalty = 0;
    const pages=cards.filter(isPage), non=cards.filter(c=>!isPage(c));
    res.jokersUsed=pages.length;

    if(non.length===0){
      if(pages.length===2){res.valid=true;res.kind='PAGE_ONLY';res.points=4;return res;}
      if(pages.length===3){res.valid=true;res.kind='PAGE_ONLY';res.points=7;res.bonus={draw:3};return res;}
      if(pages.length===4){res.valid=true;res.kind='PAGE_ONLY';res.points=15;res.bonus={refill:true};return res;}
      res.reason='Need 2‚Äì4 Pages for Page-only'; return res;
    }

    const sameSuit=non.every(c=>c.suit===non[0].suit);
    const suit=sameSuit?non[0].suit:null;
    res.suit=suit;

// RUNS: must be one suit (Pages allowed as gaps); Aces can be 1 or 14 for validation,
// but ALWAYS score as 1.
if (cards.length >= 3 && sameSuit) {
  const aceHighVals = non.map(c => (c.rank === 'A' ? 14 : RVAL(c.rank)));
  const aceLowVals  = non.map(c => RVAL(c.rank)); // A = 1

  function analyze(vals){
    const arr = vals.slice().sort((a,b)=>a-b);
    // no duplicate ranks in a run
    for (let i=1;i<arr.length;i++){
      if (arr[i] === arr[i-1]) return {ok:false, gaps:1e9};
    }
    let gaps = 0;
    for (let i=1;i<arr.length;i++){
      const diff = arr[i] - arr[i-1];
      if (diff <= 0) return {ok:false, gaps:1e9};
      gaps += (diff - 1);
    }
    return {ok:true, gaps};
  }

  const A = analyze(aceLowVals);
  const B = analyze(aceHighVals);
  const best = (B.gaps < A.gaps ? B : A); // pick the easier interpretation

  if (best.ok && best.gaps <= pages.length) {
  // Aces always score low (1)
  const sum = non.reduce((s,c)=> s + RVAL(c.rank), 0);

  res.valid = true;
  res.kind = 'RUN';

  // Pages only extend length, never add rank value
  res.points = sum + non.length + pages.length;

  // Apply page penalties
if (pages.length > 0) {
  res.points -= pages.length;     // ‚àí1 each
  res.pagePenalty = pages.length; // record penalty for logging/preview
} else {
  res.pagePenalty = 0;
}

  // Suit bonus only if no Pages
  if (pages.length === 0) {
    applySuitBonus(res, true);
  }

  return res;
}
}
    
    if(cards.length===2 && pages.length===0){
      if(non[0].rank===non[1].rank){
        const pts=(non[0].suit===non[1].suit)?5:2;
        res.valid=true;res.kind=(pts===5?'TRUE_PAIR':'PAIR');res.points=pts;res.pagePenalty=0;
        if(pts===5 && suit) applySuitBonus(res,true);
        return res;
      }
    }

    if(pages.length===0 && non.length>=3 && non.every(c=>c.rank===non[0].rank)){
      const r=RVAL(non[0].rank), n=cards.length; let pts=0;
      if(n===3) pts=2*r+2;
      else if(n===4){ const suits=new Set(non.map(c=>c.suit)); pts=(suits.size===4)?4*r:3*r; }
      else if(n>=5) pts=3*r+2;
      res.valid=true;res.kind='SET';res.points=pts; res.pagePenalty=0; if(suit) applySuitBonus(res,true);
      return res;
    }

    if (non.length >= 2 && non.every(c => c.rank === non[0].rank) && cards.length >= 3 && pages.length > 0) {
  const r = RVAL(non[0].rank);
  const n = non.length + pages.length;  // total cards in the set

  let pts = 0;
  if (n === 3) pts = 2 * r + 2;
  else if (n === 4) {
    const suits = new Set(non.map(c => c.suit));
    pts = (suits.size === 4) ? 4 * r : 3 * r;
  }
  else if (n >= 5) pts = 3 * r + 2;

  // apply penalties
  pts -= pages.length;
  res.pagePenalty = pages.length;

  res.valid = true;
  res.kind = 'SET';
  res.points = pts;

  if (suit && n >= 5) applySuitBonus(res, true);

  return res;
}


    res.reason='Not a valid Construct'; return res;
  }
 function applySuitBonus(res, allow){
  if(!res.suit || !allow) return;
  if(res.suit==='‚ô•'){ res.points+=3; res.suitBonus='HEARTS'; }
  if(res.suit==='‚ô£'){ res.suitBonus='CLUBS'; }
  if(res.suit==='‚ô¶'){ res.suitBonus='DIAMONDS'; }
  if(res.suit==='‚ô†'){ res.suitBonus='SPADES'; }
}
  function currentSelected(pid){
    const ids=[...G.selected]; return G.players[pid].hand.filter(c=>ids.includes(c.id));
  }
  function attemptConstruct(pid){
    const cards=currentSelected(pid);
    if(cards.length<2){ log('Select 2+ cards for a construct'); return null }
    const check=validateConstruct(cards);
    if(!check.valid){ log(check.reason||'Invalid construct'); return null }

    if(check.jokersUsed>0 && check.kind!=='PAGE_ONLY'){
      const excluded=new Set(cards.map(c=>c.id));
      const pool=G.players[pid].hand.filter(c=>!excluded.has(c.id)&&!isPage(c));
      if(pool.length<check.jokersUsed){ log('Not enough cards to pay Page cost'); return null }

      if(Pref.mode==='solo' || pid!==myPid()){
        pool.sort((a,b)=>RVAL(a.rank)-RVAL(b.rank));
        const extras=pool.slice(0,check.jokersUsed).map(c=>c.id);
        return {type:'CONSTRUCT',pid,ids:cards.map(c=>c.id),extras,info:check};
      } else {
        openPayDrawer(pid,cards.map(c=>c.id),check.jokersUsed,pool); return null;
      }
    }
    return {type:'CONSTRUCT',pid,ids:cards.map(c=>c.id),extras:[],info:check};
  }
function updateConstructPreview(){
  const host = $('constructPreview');
  const kindEl = $('previewKind'), ptsEl = $('previewPoints');
  const extraEl = $('previewExtras'), whyEl = $('previewWhy');
  const btn = $('previewPlay');

  const pid = myPid();
  const cards = currentSelected(pid);

  // reset UI
  host.style.display = 'none';
  btn.style.display = 'none';
  extraEl.style.display = 'none';
  whyEl.style.display = 'none';
  document.querySelectorAll('.card.selected').forEach(n=>n.classList.remove('preview-glow'));

  if (!cards || cards.length < 2) return;

  const res = validateConstruct(cards);

  host.style.display = 'flex';
  if (res.valid){
    kindEl.textContent = res.kind.replace('_',' ');

// build the points note first
let note = `+${res.points}`;
if (res.suitBonus==='HEARTS')   note += ' (‚ô• +3)';
if (res.suitBonus==='CLUBS')    note += ' (‚ô£ extra turn)';
if (res.suitBonus==='DIAMONDS') note += ' (‚ô¶ steal)';
if (res.suitBonus==='SPADES')   note += ' (‚ô† steal cards)';

// append page penalty if applicable
if (res.valid && res.kind!=='PAGE_ONLY' && (res.pagePenalty||0) > 0){
  note += ` (‚àí${res.pagePenalty} Pages)`;
}

ptsEl.textContent = note;
    ptsEl.classList.remove('preview-bad'); ptsEl.classList.add('preview-good');

    if (res.jokersUsed>0 && res.kind!=='PAGE_ONLY'){
      extraEl.style.display = 'inline-block';
      extraEl.textContent = `Pay Page cost: discard ${res.jokersUsed}`;
    }

    // glow selected
    $('yourHand').querySelectorAll('.card.selected').forEach(n=>n.classList.add('preview-glow'));
    btn.style.display = (G.turn===pid) ? 'inline-block' : 'none';
  } else {
    kindEl.textContent = 'Not a construct';
    ptsEl.textContent = '‚Äî';
    ptsEl.classList.remove('preview-good'); ptsEl.classList.add('preview-bad');
    whyEl.style.display = 'inline'; whyEl.textContent = res.reason || 'Invalid';
  }
}
$('previewPlay').onclick = ()=>{
  const act = attemptConstruct(myPid());
  if (act) userAction(act);
};
  // LOG
  function log(s){
    const el=$('log'); if(el){ const d=document.createElement('div'); d.className='line'; d.textContent=s; el.appendChild(d); el.scrollTop=el.scrollHeight; flashLogLast() }
    if(Net.isOnline() && Pref.role==='host'){ sendSig({kind:'LOG', text:s}) }
  }

  // APPLY core
  function applyAction(act){
    const pid=act.pid; const opp=1-pid;
    switch(act.type){
      case 'START': startNew(); if(Net.isOnline() && Pref.role==='host'){ sendSync(1) } return;

      case 'CONSTRUCT': {
        const cards=removeFromHandByIds(pid,act.ids); const check=validateConstruct(cards);
        if(!check.valid){ G.players[pid].hand.push(...cards); log('Invalid construct (check)'); render(); return }
        if(check.kind!=='PAGE_ONLY' && check.jokersUsed>0){
          const extraCards=removeFromHandByIds(pid,act.extras);
          if(extraCards.length!==check.jokersUsed){ G.players[pid].hand.push(...cards,...extraCards); log('Page cost mismatch'); render(); return }
          G.discard.push(...extraCards);
          log(`Paid Page cost: discarded ${extraCards.length}.`);
        }
        G.players[pid].score+=check.points; bumpScore(pid);
        G.discard.push(...cards);
        log(`${pid===0?'P1':'P2'} played ${check.kind} for +${check.points}.`); buzz(20);
        if (check.kind!=='PAGE_ONLY' && (check.pagePenalty||0) > 0){
  log(`Page penalty ‚àí${check.pagePenalty}.`);
}
        
        // Explicit suit-bonus logs
if (check.suitBonus === 'HEARTS')   log('‚ô• bonus: +3.');
if (check.suitBonus === 'CLUBS')    log('‚ô£ bonus: extra turn.');
if (check.suitBonus === 'DIAMONDS') log('‚ô¶ bonus: steal points.');
if (check.suitBonus === 'SPADES')   log('‚ô† bonus: steal up to 2 cards.');

if (check.suitBonus === 'HEARTS')  suitBanner('‚ô•', '+3 points');
if (check.suitBonus === 'CLUBS')   suitBanner('‚ô£', 'Take another turn (cap 2)');
if (check.suitBonus === 'DIAMONDS') suitBanner('‚ô¶', 'Roll d6 to steal 1‚Äì3');
if (check.suitBonus === 'SPADES')  suitBanner('‚ô†', 'Steal up to 2 random cards');
        
        if(check.kind==='PAGE_ONLY'){
          if (check.bonus && check.bonus.draw) {
  draw(pid, check.bonus.draw);
  log(`Drew ${check.bonus.draw}.`);
}
          if (check.bonus && check.bonus.refill) {
  const need = Math.max(0, 7 - G.players[pid].hand.length);
  if (need > 0) {
    draw(pid, need);
    log('Refilled to 7.');
  }
}
        }
        if(check.suitBonus==='DIAMONDS'){
          const roll=1+Math.floor(Math.random()*6);
          const steal=(roll<=2)?1:(roll<=4)?2:3;
          const give=Math.min(steal,G.players[opp].score);
          G.players[opp].score-=give; G.players[pid].score+=give; bumpScore(pid);
          log(`‚ô¶ d6=${roll} ‚Üí stole ${give}.`); toast(`<div>‚ô¶ Diamonds roll: <span class="die">${roll}</span> ‚Üí +${give}</div>`);
        }
        if(check.suitBonus==='SPADES'){
          const oppH=G.players[opp].hand;
          for(let i=0;i<2 && oppH.length>0;i++){ const j=rnd(oppH.length); const c=oppH.splice(j,1)[0]; G.players[pid].hand.push(c) }
          log(`‚ô† stole up to 2 random card(s).`); toast(`<div>‚ô† Stole up to 2 random cards</div>`);
        }
if (pid===0){ Telemetry.player.constructs++; markPlayerTurn('construct'); }
        const extraTurn=(check.suitBonus==='CLUBS');
        if(G.players[pid].score>=60){ log(`${pid===0?'P1':'P2'} win (60)!`); buzz(60); G.started=false; render(); saveState(); if(Net.isOnline()&&Pref.role==='host'){sendSync(1)} return }

       if(extraTurn){
  // clear any stale selections from the construct before the bonus turn
  G.selected.clear();
  render(); // update ARIA pressed states/visuals

  endOfTurnDraw(pid); // you still draw 1 at the end of that construct turn
  G.clubChain=(G.turn===pid ? G.clubChain+1 : 1);
  if(G.clubChain<=2){
    log(`${pid===0?'P1':'P2'} take an extra turn (${G.clubChain}/2).`);
    ensureMyTurnUI();
    render(); maybeSafetyDraw(); saveState();
    if(Pref.mode==='solo' && pid===1) setTimeout(aiTakeTurn,380);
    if(Net.isOnline() && Pref.role==='host'){ sendSync(1) }
    return;
  } else {
    log(`Clubs extra-turn cap reached (2); passing turn.`); G.clubChain=0;
  }
}
        G.selected.clear(); endTurn(); return;
      }

      case 'ACTION_6': {
        const c=discardFromHandById(pid,act.cardId);
        if(!c){ log('6: invalid card.'); return }
        draw(pid,2); log(`${pid===0?'P1':'P2'} played 6 (Draw2).`);
if (pid===0){ Telemetry.player.actions++; markPlayerTurn('action'); }
G.selected.clear(); endTurn(); return;
      }

      case 'ACTION_7': {
        const c=discardFromHandById(pid,act.cardId);
if(!c){ log('7: invalid card.'); return }
if (pid===0){ Telemetry.player.actions++; markPlayerTurn('action'); }
G.selected.clear(); return queryAce('A7',pid,1-pid,{cardId:act.cardId});
      }

      case 'ACTION_9': {
        const giveCard=G.players[pid].hand.find(c=>c.id===act.giveId);
        if(!giveCard){ log('9: invalid give card.'); return }
        const nine=G.players[pid].hand.find(c=>c.id===act.cardId && c.rank==='9');
        if(!nine){ log('9: invalid 9.'); return }
        discardFromHandById(pid,nine.id); takeFromHandById(pid,giveCard.id);
if (pid===0){ Telemetry.player.actions++; markPlayerTurn('action'); }
G.selected.clear(); return queryAce('A9',pid,1-pid,{give:giveCard});
      }

      case 'SIGIL': {
        const s=G.players[pid].hand.find(c=>c.id===act.cardId && isJQK(c.rank));
        if(!s || s.rank!==act.rank){ log('Sigil: invalid card.'); return }
        const r=s.rank; discardFromHandById(pid,s.id);
        const target=1-pid; const tHand=G.players[target].hand;
        const aceCount=tHand.filter(c=>c.rank==='A').length;

        if(aceCount>=2){
          if(Net.isOnline() && Pref.role==='host' && target===1){
            G.aceQuery={kind:'ASIG',actor:pid,target,info:{rank:r,mode:act.mode}};
sendSig({kind:'ACE_PROMPT', data:{kind:'ASIG', rank:r, mode:act.mode}});
log(`Sigil ${r}: waiting for defender...`); return;
          }
          if(target===1 && Pref.mode==='solo'){
            spendNAces(target,2); log(`Sigil blocked by 2 Aces ‚Üí Sigil discarded.`); toast(`<div>üõ°Ô∏è Sigil blocked by 2 Aces</div>`); endTurn(); return;
          }
          if(target===0){
            G.aceQuery={kind:'ASIG',actor:pid,target,info:{rank:r,mode:act.mode}};
            $('acePrompt').textContent=`Opponent played ${r}. Discard 2 Aces to block?`; openAceDrawer(); return;
          }
        }

        if(act.mode==='points'){ const add=(r==='J'?1:r==='Q'?2:3); G.players[pid].score+=add; bumpScore(pid); log(`${pid===0?'P1':'P2'} played ${r}: +${add}.`); }
        else { const drawN=(r==='K'?2:1); draw(pid,drawN); log(`${pid===0?'P1':'P2'} played ${r}: draw ${drawN}.`); }

        if (pid===0){ Telemetry.player.sigils++; markPlayerTurn('sigil'); }
        
        if (G.players[pid].score >= 60) {
  log(`${pid===0?'P1':'P2'} win (60)!`);
  buzz(60);
  G.started = false;
  render(); saveState();
  if (Net.isOnline() && Pref.role === 'host') { sendSync(1); }
  return;
}
        G.selected.clear(); endTurn(); return;
      }

      case 'DISCARD': {
        const c=discardFromHandById(pid,act.cardId);
        if(!c){ log('Invalid discard.'); return }
        G.players[pid].score+=1; bumpScore(pid);
        log(`${pid===0?'P1':'P2'} discarded ${c ? (c.rank + (c.suit||'')) : '‚Äî'} for +1.`);

if (pid===0){ Telemetry.player.discards++; markPlayerTurn('discard'); }
        
        if (G.players[pid].score >= 60) {
  log(`${pid===0?'P1':'P2'} win (60)!`);
  buzz(60);
  G.started = false;
  render(); saveState();
  if (Net.isOnline() && Pref.role === 'host') { sendSync(1); }
  return;
}
        G.selected.clear(); endTurn(); return;
      }
    }
  }

  function aceResolveNoUse(kind,actor,target,info){
    if(kind==='A7'){
      const th=G.players[target].hand;
      if(th.length>0){ const j=rnd(th.length); const c=th.splice(j,1)[0]; G.players[actor].hand.push(c); log('7: stole a random card.'); toast('<div>7 resolved: stole a random card</div>') }
      else log('7: defender had no cards.');
      return endTurn();
    }
    if(kind==='A9'){
      const th=G.players[target].hand;
      if(th.length>0){ const j=rnd(th.length); const c=th.splice(j,1)[0]; G.players[actor].hand.push(c); log('9: swapped one card.'); toast('<div>9 resolved: swapped one card</div>') }
      else log('9: defender had no cards.');
      if (info && info.give) G.players[target].hand.push(info.give);
      return endTurn();
    }
    if(kind==='ASIG'){
      const {rank,mode}=info||{};
      if(mode==='points'){ const add=(rank==='J'?1:rank==='Q'?2:3); G.players[actor].score+=add; bumpScore(actor); log(`${actor===0?'P1':'P2'} played ${rank}: +${add}.`); }
      else { const drawN=(rank==='K'?2:1); draw(actor,drawN); log(`${actor===0?'P1':'P2'} played ${rank}: draw ${drawN}.`); }

      if (actor === 0){ Telemetry.player.sigils++; markPlayerTurn('sigil'); }
      
      if (G.players[actor].score >= 60) {
  log(`${actor===0?'P1':'P2'} win (60)!`);
  buzz(60);
  G.started = false;
  render(); saveState();
  if (Net.isOnline() && Pref.role === 'host') { sendSync(1); }
  return;
}
      return endTurn();
    }
  }

  function queryAce(kind,actor,target,info){
    if(Net.isOnline() && Pref.role==='host' && target===1){
      G.aceQuery={kind,actor,target,info};
      sendSig({kind:'ACE_PROMPT', data:{kind,actor,target,info}});
      log('Waiting for defender...'); return;
    }
    if(target===0){
      if((kind==='A7'||kind==='A9') && !haveNAces(target,1)) return aceResolveNoUse(kind,actor,target,info);
      if(kind==='ASIG' && !haveNAces(target,2)) return aceResolveNoUse(kind,actor,target,info);
      G.aceQuery={kind,actor,target,info};
      $('acePrompt').textContent=
        kind==='A7'?"Use an Ace to try to block 7? (d6: 4‚Äì6 blocks + counter)":
        kind==='A9'?"Use an Ace to try to block 9? (d6: 4‚Äì6 blocks + counter)":
        'Use 2 Aces to auto-block the Sigil?';
      openAceDrawer(); return;
    }
    if(Pref.mode==='solo' && target===1){
      const use=aiWantsAce(target);
      if(!use) return aceResolveNoUse(kind,actor,target,info);
      const roll=1+Math.floor(Math.random()*6);
      if(roll<=3){ log(`Ace block (d6=${roll}) ‚Üí FAIL.`);
toast(`<div>üÇ± Ace roll <span class='die'>${roll}</span> ‚Üí fail</div>`); return aceResolveNoUse(kind,actor,target,info) }
      else { spendNAces(target,1); G.players[target].score+=1; bumpScore(target); if (kind === 'A9' && info && info.give) {
  G.discard.push(info.give);
} log(`Ace block (d6=${roll}) ‚Üí BLOCKED +1.`);
toast(`<div>üõ°Ô∏è Ace roll <span class='die'>${roll}</span> ‚Üí block +1</div>`); return endTurn() }
    }
  }

  function spendNAces(pid,n){
    const h=G.players[pid].hand; let used=0;
    for(let i=0;i<h.length&&used<n;){ if(h[i].rank==='A'){ G.discard.push(h.splice(i,1)[0]); used++ } else i++ }
    return used===n;
  }
  function haveNAces(pid,n){ return G.players[pid].hand.filter(c=>c.rank==='A').length>=n }

  // === AI ===
  function aiFind(pid,rank){ return G.players[pid].hand.find(c=>c.rank===rank) }
  function aiPickSigil(pid){
  const h = G.players[pid].hand;
  const s = h.find(c => isJQK(c.rank));
  if (!s) return null;

  const me = G.players[pid], opp = G.players[1-pid];
  const need = 60 - me.score;
  const gain = (s.rank==='J'?1:s.rank==='Q'?2:3);

  // lethal points ‚Üí always take points
  if (gain >= need) return { id:s.id, rank:s.rank, mode:'points' };

  const oppHandBig = G.players[1-pid].hand.length >= 6;
  const playerBlocksOften = Telemetry.player.blocksByAce >= 2;

  // risk: if opp likely to autoblock (big hand / has been blocking), prefer draw when not lethal
  const risky = oppHandBig || playerBlocksOften;

  // prefer draw when our hand is thin or risk is high; K draws 2 so extra nice when low
  const wantDraw = (h.length <= 4) || risky || (s.rank==='K' && h.length<=6);

  return { id:s.id, rank:s.rank, mode: (wantDraw ? 'draw' : 'points') };
}
  function aiPickTrash(pid){
  const h = G.players[pid].hand.slice();
  const me = G.players[pid], opp = G.players[1-pid];
  const expert = (Pref.ai === 'expert');
  const weAreBehind = me.score < opp.score;

  function clusterScore(c){
    if (isPage(c)) return 5.5;                          // keep pages
    if (c.rank === 'A') return 5.2;                     // keep aces (defense / counter / sigil autoblock)
    if (isJQK(c.rank)) return 4.8;                      // keep sigils
    if (c.rank==='6'||c.rank==='7'||c.rank==='9') return 4.4; // actions = tactical

    // set potential
    const same = h.filter(x => !isPage(x) && x.rank === c.rank).length;
    // run potential (neighbors in suit)
    const v = RVAL(c.rank);
    const near = h.filter(x => !isPage(x) && x.suit===c.suit && Math.abs(RVAL(x.rank)-v)===1).length;
    // suit cluster (help suit bonuses later)
    const suitCount = h.filter(x => !isPage(x) && x.suit===c.suit).length;

    let s = 0.0;
    s += (same>=3 ? 3.4 : same===2 ? 2.4 : same===1 ? 1.2 : 0.2);
    s += (near>=2 ? 2.6 : near===1 ? 1.4 : 0.0);
    s += (suitCount>=3 ? 0.8 : 0.0);                     // small nudge to keep clusters
    return s;
  }

  // Lower score = better trash
  h.sort((a,b)=> clusterScore(a) - clusterScore(b));

  let cand = h[0];

  // EXPERT safeguards: if behind, don't discard 7/9/6 unless nothing else
  if (expert && weAreBehind){
    const safer = h.find(c => !(c.rank==='7'||c.rank==='9'||c.rank==='6'||isJQK(c.rank)||c.rank==='A'||isPage(c)));
    if (safer) cand = safer;
  }

  return cand;
}
  function aiChooseGive(pid, nineId){
  const pool = G.players[pid].hand.filter(c => c.id !== nineId).slice();
  // rank by "keep value" (lower is worse ‚Üí choose first)
  function keepValue(c){
    if (isPage(c)) return 100;
    if (c.rank==='A') return 90;
    if (c.rank==='K') return 80;
    if (c.rank==='Q') return 75;
    if (c.rank==='J') return 70;
    if (c.rank==='9') return 60;
    if (c.rank==='7') return 55;
    if (c.rank==='6') return 50;

    // synergy fallback
    const v = RVAL(c.rank);
    const same = pool.filter(x => !isPage(x) && x.rank===c.rank).length;
    const near = pool.filter(x => !isPage(x) && x.suit===c.suit && Math.abs(RVAL(x.rank)-v)===1).length;
    return v - 0.8*same - 0.6*near;
  }
  pool.sort((a,b)=> keepValue(a) - keepValue(b));
  return pool[0] ? pool[0].id : undefined;
}
  function aiWantsAce(pid){
  // Should AI spend an Ace to block 7/9? (For Sigil autoblock, separate rule in query)
  const me = G.players[pid], opp = G.players[1-pid];
  const expert = (Pref.ai === 'expert');

  const myAces = me.hand.filter(c=>c.rank==='A').length;
  if (myAces === 0) return false;

  const myTo60  = 60 - me.score;
  const oppTo60 = 60 - opp.score;
  const weAreBehind = me.score < opp.score;

  // Baseline tendencies by difficulty
  if (!expert){
    if (Pref.ai === 'easy')  return Math.random() < 0.35;
    if (Pref.ai === 'hard')  return Math.random() < 0.8 || myTo60<=5 || oppTo60<=5 || me.hand.length>=5;
    // normal
    return Math.random() < 0.6 || myTo60<=5 || oppTo60<=5;
  }

  // Expert:
  // Spend if blocking prevents lethal swing or when behind and hand is healthy.
  if (oppTo60 <= 4) return true;              // they‚Äôre about to win ‚Üí block
  if (weAreBehind && me.hand.length >= 5) return true;   // we need the tempo
  if (myTo60 <= 4) return false;              // save for our own finish or sigil autoblock
  // If we have 2+ Aces, more liberal
  if (myAces >= 2) return true;

  // Slight randomness to avoid total predictability
  return Math.random() < 0.55;
}
  function combos(arr,k,cap=9999){
    const out=[]; const n=arr.length;
    const rec=(start,take,buf)=>{ if(out.length>=cap) return; if(take===0){ out.push(buf.slice()); return } for(let i=start;i<=n-take;i++){ buf.push(arr[i]); rec(i+1,take-1,buf); buf.pop(); if(out.length>=cap) return } };
    rec(0,k,[]); return out;
  }
  function aiBestConstruct(pid){
  const hand = G.players[pid].hand;
  let best = null, bestScore = -1e9;

  const ids = hand.map(c => c.id);
  const me  = G.players[pid];
  const opp = G.players[1 - pid];
  const myTo60  = 60 - me.score;
  const oppTo60 = 60 - opp.score;
  const behind  = me.score < opp.score;
  const expert  = (Pref.ai === 'expert');

  // EXPERT: search more combinations (still safe in-browser)
  const cap = (
    Pref.ai === 'easy'   ? 120   :
    Pref.ai === 'normal' ? 250   :
    Pref.ai === 'hard'   ? 2000  :
    /* expert */           12000
  );

  // phase weights
  const W = {
    // base
    pts: 1.0,
    size: expert ? 0.25 : 0.10,            // prefer bigger melds a bit
    usePage: expert ? -1.2 : -0.6,         // pages used inside melds hurt
    burnPower: expert ? -1.0 : -0.3,       // burning A/6/7/9/J/Q/K inside a construct is costly
    // suit bonuses
    hearts: expert ? 2.2 : 0.7,
    diamonds: expert ? 4.8 : 1.0,
    spades: expert ? 3.0 : 0.8,
    clubs: expert ? 6.5 : 1.6,
    // phase sensitive
    lethal: 9.0,                            // any construct that wins
    catchUp: behind ? 1.6 : 0.0,            // more value if behind
    nearWin: (myTo60 <= 8) ? 1.4 : 0.0,     // prioritize quick scoring when close
    oppClose: (oppTo60 <= 8) ? -0.4 : 0.0   // mild penalty vs slow lines when opp is close
  };

  function cardIsPower(c){
    return isPage(c) || c.rank==='A' || isJQK(c.rank) || c.rank==='6' || c.rank==='7' || c.rank==='9';
  }

  for (let len = Math.min(7, hand.length); len >= 2; len--){
    const comb = combos(ids, len, cap);
    for (const set of comb){
      const cards = hand.filter(c => set.includes(c.id));
      const check = validateConstruct(cards);
      if (!check.valid) continue;

      // base score = raw points
      let s = W.pts * check.points;

      // suit bonus shaping
      if (check.suitBonus === 'HEARTS')   s += W.hearts;
      if (check.suitBonus === 'DIAMONDS') s += W.diamonds;
      if (check.suitBonus === 'SPADES')   s += W.spades;
      if (check.suitBonus === 'CLUBS')    s += W.clubs;

      // size encouragement
      s += W.size * cards.length;

      // penalties for using jokers or power cards in the meld
      const usesPage  = cards.some(isPage);
      const usesPower = cards.some(cardIsPower);
      if (usesPage)  s += W.usePage * (check.jokersUsed || 1);
      if (usesPower) s += W.burnPower;

      // phase tweaks
      if (me.score + check.points >= 60) s += W.lethal;
      s += W.catchUp + W.nearWin + W.oppClose;

      // EXPERT: prefer club-chaining if we still have stuff to do next turn
      if (expert && check.suitBonus === 'CLUBS' && (G.turn === pid) && (G.clubChain < 2)){
        // reward more when we keep at least 1 action/sigil/ace in hand
        const rest = hand.filter(c => !set.includes(c.id));
        const hasTempo = rest.some(c => c.rank==='6' || c.rank==='7' || c.rank==='9' || isJQK(c.rank) || c.rank==='A');
        if (hasTempo) s += 2.8;
      }

      // Ensure page-cost feasibility (already in your code)
      let extras = [];
      if (check.jokersUsed > 0 && check.kind !== 'PAGE_ONLY'){
        const excl = new Set(set);
        const pool = hand.filter(c => !excl.has(c.id) && !isPage(c));
        pool.sort((a,b)=>RVAL(a.rank)-RVAL(b.rank));
        if (pool.length >= check.jokersUsed){
          extras = pool.slice(0, check.jokersUsed).map(c=>c.id);
        } else {
          continue;
        }
      }

      if (s > bestScore){
        bestScore = s;
        best = { ids: set.slice(), info: check, extras };
      }
    }
    if (best) break; // take the best of the longest size first
  }
  return best;
}
  function aiTakeTurn(){
  if (!G.started || G.turn !== 1) return;
  const pid=1, me=G.players[1], opp=G.players[0];
  const myTo60  = 60 - me.score;
  const oppTo60 = 60 - opp.score;
  const handLen = me.hand.length;
  const expert  = (Pref.ai === 'expert');

  const best = aiBestConstruct(pid);
  const sig  = aiPickSigil(pid);
  const a7   = aiFind(pid,'7');
  const a9   = aiFind(pid,'9');
  const a6   = aiFind(pid,'6');

  // telemetry reads
  const playerIsBuilder =
    (Telemetry.turnsSincePlayerAction >= 2) ||
    (Telemetry.player.constructs > (Telemetry.player.actions + Telemetry.player.sigils));
  const playerBlocksOften = Telemetry.player.blocksByAce >= 2;

  // 0) Lethal first
  if (best && me.score + best.info.points >= 60){
    applyAction({type:'CONSTRUCT', pid, ids:best.ids, extras:best.extras||[], info:best.info});
    return;
  }
  if (sig){
    const gain = (sig.rank==='J'?1:sig.rank==='Q'?2:3);
    if (me.score + gain >= 60){
      applyAction({type:'SIGIL', pid, rank:sig.rank, cardId:sig.id, mode:sig.mode});
      return;
    }
  }

  // 1) Opponent close to winning ‚Üí disrupt (7/9) before value
  if (expert && oppTo60 <= 8){
    if (a7){ applyAction({type:'ACTION_7', pid, cardId:a7.id}); return; }
    if (a9){ const giveId = aiChooseGive(pid, a9.id); applyAction({type:'ACTION_9', pid, cardId:a9.id, giveId}); return; }
  }

  // 2) High-value construct (threshold depends on phase)
  if (best){
    const pts = best.info.points;
    const threshold = expert ? (myTo60 <= 12 ? 9 : 11) : 7;
    if (pts >= threshold){
      applyAction({type:'CONSTRUCT', pid, ids:best.ids, extras:best.extras||[], info:best.info});
      return;
    }
  }

  // 3) If player is ‚Äúbuilder‚Äù, push disruption even if not behind
  if (expert && playerIsBuilder){
    if (a9){ const giveId = aiChooseGive(pid, a9.id); applyAction({type:'ACTION_9', pid, cardId:a9.id, giveId}); return; }
    if (a7){ applyAction({type:'ACTION_7', pid, cardId:a7.id}); return; }
  }

  // 4) If behind, use 7 to pressure; if not, look to sigils
  const weAreBehind = me.score < opp.score;
  if (expert && weAreBehind && a7){
    applyAction({type:'ACTION_7', pid, cardId:a7.id}); return;
  }

  // 5) Sigil with mode chosen by aiPickSigil
  if (sig){
    // If opponent blocks often & hand is tiny, bias draw again
    const forceDraw = playerBlocksOften && handLen <= 4;
    applyAction({type:'SIGIL', pid, rank:sig.rank, cardId:sig.id, mode: (forceDraw ? 'draw' : sig.mode)});
    return;
  }

  // 6) Gas up when thin
  if (a6 && handLen <= (expert ? 6 : 5)){
    applyAction({type:'ACTION_6', pid, cardId:a6.id}); return;
  }

  // 7) Any decent construct now
  if (best){
    applyAction({type:'CONSTRUCT', pid, ids:best.ids, extras:best.extras||[], info:best.info});
    return;
  }

  // 8) Fallback: discard
  const toss = aiPickTrash(pid);
  applyAction({type:'DISCARD', pid, cardId:toss.id});
}

  // Online messages
  function onSignal(p){
    if(p.kind==='SYNC'){ const o=deserialize(p.state); if(o){ Object.assign(G,o); render() } }
    if(p.kind==='LOG'){
      const el=$('log');
      if(el){ const d=document.createElement('div'); d.className='line'; d.textContent=p.text; el.appendChild(d); el.scrollTop=el.scrollHeight; flashLogLast() }
    }
    if(p.kind==='INPUT' && Pref.role==='host'){ const act=p.act; if(!act) return; act.pid=1; applyAction(act); sendSync(1) }
    if(p.kind==='ACE_PROMPT'){
      if(Pref.role==='guest'){
        const q=p.data;
        G.aceQuery={kind:q.kind,actor:0,target:1,info:q.info||{rank:q.rank,mode:q.mode}};
        $('acePrompt').textContent=
          q.kind==='A7'?"Use an Ace to try to block 7? (d6: 4‚Äì6 blocks + counter)":
          q.kind==='A9'?"Use an Ace to try to block 9? (d6: 4‚Äì6 blocks + counter)":
          'Use 2 Aces to auto-block the Sigil?';
        openAceDrawer();
      }
    }
    if(p.kind==='ACE_RESPONSE' && Pref.role==='host'){
      const {use}=p; const {kind,actor,target,info}=G.aceQuery||{};
      if(!kind) return;
      if(kind==='ASIG'){
        if(use && haveNAces(1,2)){
  spendNAces(1,2); log(`Sigil blocked by 2 Aces ‚Üí Sigil discarded.`); toast(`<div>üõ°Ô∏è Sigil blocked by 2 Aces</div>`);
G.aceQuery=null; endTurn(); return
}
        G.aceQuery=null; return aceResolveNoUse('ASIG',actor,target,info);
      } else {
        if(!use){ G.aceQuery=null; return aceResolveNoUse(kind,actor,target,info) }
        const roll=1+Math.floor(Math.random()*6);
        if(roll<=3){ log(`Ace block (d6=${roll}) ‚Üí FAIL.`); toast(`<div>üÇ± Ace roll <span class='die'>${roll}</span> ‚Üí fail</div>`); G.aceQuery=null; return aceResolveNoUse(kind,actor,target,info) }
        else {
  spendNAces(1,1); G.players[1].score+=1; bumpScore(1);
if (kind === 'A9' && info && info.give) G.discard.push(info.give);
log(`Ace block (d6=${roll}) ‚Üí BLOCKED +1.`); toast(`<div>üõ°Ô∏è Ace roll <span class='die'>${roll}</span> ‚Üí block +1</div>`);
G.aceQuery=null; return endTurn()
}
      }
    }
  }

  // Drawers logic (now using openDrawer/closeDrawer)
  const payDrawer=$('payDrawer'), payGrid=$('payGrid'), payHint=$('payHint'), payCancel=$('payCancel'), payConfirm=$('payConfirm');
  let _pendingPay=null;
  function openPayDrawer(pid,baseIds,need,poolCards){
    _pendingPay={pid,baseIds,need,poolIds:poolCards.map(c=>c.id),chosen:new Set()};
    payHint.textContent=`Select ${need} card${need>1?'s':''} to discard (Page cost).`;
    payGrid.innerHTML='';
    poolCards.forEach(c=>{
      const n=cardNode(c,true);
      n.onclick=()=>{
        const chosen=_pendingPay.chosen;
        if(chosen.has(c.id)){ chosen.delete(c.id); n.classList.remove('selected') }
        else { chosen.add(c.id); n.classList.add('selected') }
        payConfirm.disabled=(chosen.size!==need);
      };
      payGrid.appendChild(n);
    });
    payConfirm.disabled=true; openDrawer(payDrawer);
  }
  payCancel.onclick=()=>{ closeDrawer(payDrawer); _pendingPay=null };
  payConfirm.onclick=()=>{ if(!_pendingPay) return;
    const {pid,baseIds,chosen}=_pendingPay; const extras=[...chosen];
    closeDrawer(payDrawer); _pendingPay=null;
    userAction({type:'CONSTRUCT',pid,ids:baseIds,extras});
  };

  const giveDrawer=$('giveDrawer'), giveGrid=$('giveGrid'), giveCancel=$('giveCancel');
  function openGiveDrawer(nineCard){
    G.chooseGive={nineId:nineCard.id,actorPid:myPid()};
    giveGrid.innerHTML='';
    G.players[myPid()].hand.filter(c=>c.id!==nineCard.id).forEach(c=>{
      const n=cardNode(c,true);
      n.onclick=()=>{ closeDrawer(giveDrawer); userAction({type:'ACTION_9',pid:myPid(),cardId:nineCard.id,giveId:c.id}); G.chooseGive=null };
      giveGrid.appendChild(n);
    });
    openDrawer(giveDrawer);
  }
  giveCancel.onclick=()=>{ closeDrawer(giveDrawer); G.chooseGive=null };

  const aceDrawer=$('aceDrawer'), aceYes=$('aceYes'), aceNo=$('aceNo');
  function openAceDrawer(){
    const need = (G.aceQuery && G.aceQuery.kind === 'ASIG') ? 2 : 1;
    $('aceYes').disabled=!haveNAces(myPid(),need);
    openDrawer(aceDrawer);
    aceDrawer.onfocusin = () => {
  const needNow = (G.aceQuery && G.aceQuery.kind === 'ASIG') ? 2 : 1;
  $('aceYes').disabled = !haveNAces(myPid(), needNow);
};
  }
  function closeAceDrawer(){ closeDrawer(aceDrawer) }
  aceNo.onclick=()=>{ if(!G.aceQuery) return closeAceDrawer(); const q=G.aceQuery; closeAceDrawer();
    if(Pref.mode==='online' && Pref.role==='guest'){ sendSig({kind:'ACE_RESPONSE', use:false}); return }
    G.aceQuery=null; aceResolveNoUse(q.kind,q.actor,q.target,q.info);
  };
  aceYes.onclick=()=>{ if(!G.aceQuery) return closeAceDrawer(); const q=G.aceQuery;
    if(q.kind==='ASIG'){
      if(haveNAces(myPid(),2)){
        if(Pref.mode==='online' && Pref.role==='guest'){ closeAceDrawer(); sendSig({kind:'ACE_RESPONSE', use:true}); return }
        spendNAces(myPid(),2); log(`Sigil blocked by 2 Aces ‚Üí Sigil discarded.`); toast(`<div>üõ°Ô∏è Sigil blocked by 2 Aces</div>`);
notePlayerAceBlockSuccess();
closeAceDrawer(); G.aceQuery=null; return endTurn();
      } else { closeAceDrawer(); G.aceQuery=null; return }
    }
    if(!haveNAces(myPid(),1)){ closeAceDrawer(); G.aceQuery=null; return }
    if(Pref.mode==='online' && Pref.role==='guest'){ closeAceDrawer(); sendSig({kind:'ACE_RESPONSE', use:true}); return }
    const roll=1+Math.floor(Math.random()*6);
    if(roll<=3){
      log(`Ace block (d6=${roll}) ‚Üí FAIL.`); toast(`<div>üÇ± Ace roll <span class='die'>${roll}</span> ‚Üí fail</div>`);
      if(q.kind==='A7'){
        const th=G.players[q.target].hand;
        if(th.length>0){ const j=rnd(th.length); const c=th.splice(j,1)[0]; G.players[q.actor].hand.push(c); log(`7: stole a random card.`) }
        else log('7: defender had no cards.');
      } else {
        const th=G.players[q.target].hand;
        if(th.length>0){ const j=rnd(th.length); const c=th.splice(j,1)[0]; G.players[q.actor].hand.push(c); log('9: swapped one card.') }
        else log('9: defender had no cards.');
        if (q.info && q.info.give) {
  G.players[q.target].hand.push(q.info.give);
}
      }
      closeAceDrawer(); G.aceQuery=null; return endTurn();
    } else {
      spendNAces(myPid(),1); G.players[myPid()].score+=1; bumpScore(myPid());
      if (q.kind === 'A9' && q.info && q.info.give) G.discard.push(q.info.give);
      log(`Ace block (d6=${roll}) ‚Üí BLOCKED +1.`); toast(`<div>üõ°Ô∏è Ace roll <span class='die'>${roll}</span> ‚Üí block +1</div>`);
      notePlayerAceBlockSuccess();
      closeAceDrawer(); G.aceQuery=null; return endTurn();
    }
  };

  // Sigil Drawer
  const sigilDrawer=$('sigilDrawer'), sigilPoints=$('sigilPoints'), sigilDraw=$('sigilDraw'), sigilCancel=$('sigilCancel');
  let _pendingSigil=null;
  function openSigil(c){
    _pendingSigil=c; $('sigilHint').textContent=`${c.rank}: Points (J+1/Q+2/K+3) or Draw (J/Q +1, K +2)`;
    openDrawer(sigilDrawer);
  }
  sigilPoints.onclick=()=>{const c=_pendingSigil;if(!c)return;closeDrawer(sigilDrawer);userAction({type:'SIGIL',pid:myPid(),rank:c.rank,cardId:c.id,mode:'points'});_pendingSigil=null};
  sigilDraw.onclick=()=>{const c=_pendingSigil;if(!c)return;closeDrawer(sigilDrawer);userAction({type:'SIGIL',pid:myPid(),rank:c.rank,cardId:c.id,mode:'draw'});_pendingSigil=null};
  sigilCancel.onclick=()=>{closeDrawer(sigilDrawer);_pendingSigil=null};

  // Settings Drawer
  const settingsDrawer=$('settingsDrawer');
  $('btnSettings').onclick=()=>{syncSettingsUI();openDrawer(settingsDrawer)};
  $('settingsClose').onclick=()=>{closeDrawer(settingsDrawer)};
  $('resetGame').onclick=()=>{localStorage.removeItem(SAVE_KEY);startNew();toast('Game reset.'); if(Net.isOnline()&&Pref.role==='host'){sendSync(1)}};
    // ---- Tutorial wiring (simple) ----
const TUTO_KEY = 'arcana_tutorial_seen_v1';

function updateTutorialDots(i){
  const dots = $('tutorialDots').querySelectorAll('.dot');
  dots.forEach((d,idx)=> d.classList.toggle('on', idx===i));
}

$('tutorialNext').onclick = ()=>{
  const steps = Array.from($('tutorialDrawer').querySelectorAll('.step'));
  let i = steps.findIndex(s=> s.classList.contains('active'));
  if (i < steps.length-1){
    steps[i].classList.remove('active');
    steps[i+1].classList.add('active');
    updateTutorialDots(i+1);
  } else {
    if ($('tutorialDontShow').checked) localStorage.setItem(TUTO_KEY, '1');
    closeDrawer($('tutorialDrawer'));
  }
};

$('tutorialPrev').onclick = ()=>{
  const steps = Array.from($('tutorialDrawer').querySelectorAll('.step'));
  let i = steps.findIndex(s=> s.classList.contains('active'));
  if (i > 0){
    steps[i].classList.remove('active');
    steps[i-1].classList.add('active');
    updateTutorialDots(i-1);
  }
};

$('tutorialClose').onclick = ()=>{
  if ($('tutorialDontShow').checked) localStorage.setItem(TUTO_KEY, '1');
  closeDrawer($('tutorialDrawer'));
};
  function syncSettingsUI(){ $('optHaptics').checked=Pref.haptics; $('optAnims').checked=Pref.anims; $('optSwipe').checked=Pref.swipe; $('optCardSize').value=Pref.cardSize; $('optAI').value=Pref.ai; $('optMode').value=Pref.mode; $('optRole').value=Pref.role; $('optRoom').value=Pref.room; $('netStatus').textContent=Net.connected?'Connected':'Offline' }
  function applySettings(){
    Pref.haptics=$('optHaptics').checked;
    Pref.anims=$('optAnims').checked;
    Pref.swipe=$('optSwipe').checked;
    Pref.cardSize=$('optCardSize').value;
    Pref.ai=$('optAI').value;
    Pref.mode=$('optMode').value;
    Pref.role=$('optRole').value;
    Pref.room=$('optRoom').value.trim();
    savePrefs();
    adjustCardSize();
    document.body.classList.toggle('no-anim', !Pref.anims);
    updateModeTag();
    updateStartDisabled();
  }
  $('optHaptics').onchange=applySettings; $('optAnims').onchange=applySettings; $('optSwipe').onchange=applySettings; $('optCardSize').onchange=applySettings; $('optAI').onchange=applySettings; $('optMode').onchange=applySettings; $('optRole').onchange=applySettings; $('optRoom').onchange=applySettings;

  function adjustCardSize(){
    const root = document.documentElement;
    if (Pref.cardSize === 'compact') root.style.setProperty('--cardW', '64px');
    else if (Pref.cardSize === 'large') root.style.setProperty('--cardW', '92px');
    else root.style.removeProperty('--cardW'); // auto via CSS clamp
  }

  function updateModeTag(){
    $('modeTag').textContent =
      Pref.mode === 'online'
        ? (Pref.role.toUpperCase() + ' ‚Ä¢ ' + (Net.connected ? 'ONLINE' : 'OFFLINE'))
        : ('SOLO ‚Ä¢ ' + Pref.ai.toUpperCase());
  }

  // Route local vs online (guest sends INPUT to host)
  function userAction(act){
    if (Pref.mode === 'online' && Pref.role === 'guest' && Net.isOnline()){
      sendSig({ kind: 'INPUT', act });
      return;
    }
    applyAction(act);
    if (Net.isOnline() && Pref.role === 'host') sendSync(1);
  }

  // === UI wiring ===
  function selectedOne(){
  const pid = myPid();
  const handIds = new Set(G.players[pid].hand.map(c => c.id));

  // prune any selected IDs that are no longer in hand
  const pruned = [...G.selected].filter(id => handIds.has(id));
  if (pruned.length !== G.selected.size) {
    G.selected = new Set(pruned);
  }

  if (pruned.length !== 1) return null;
  return G.players[pid].hand.find(c => c.id === pruned[0]) || null;
}

  function playSelectedAction(){
  if (!G.started){ log('Game not started.'); return; }
  if (G.turn !== myPid()){ log('Not your turn.'); return; }

  const c = selectedOne();
  if (!c){ log('Select exactly one action card (6/7/9).'); return; }
  if (c.rank !== '6' && c.rank !== '7' && c.rank !== '9'){ log('Not an action card.'); return; }

  const inHand = G.players[myPid()].hand.some(x => x.id === c.id);
  if (!inHand){ G.selected.clear(); render(); log('That card moved. Re-select.'); return; }

  if (c.rank === '6'){ userAction({type:'ACTION_6', pid:myPid(), cardId:c.id}); return; }
  if (c.rank === '7'){ userAction({type:'ACTION_7', pid:myPid(), cardId:c.id}); return; }
  if (c.rank === '9'){ openGiveDrawer(c); return; }
}

  function playSelectedSigil(){
  if (!G.started){ log('Game not started.'); return; }
  if (G.turn !== myPid()){ log('Not your turn.'); return; }

  const c = selectedOne();
  if (!c){ log('Select exactly one Sigil (J/Q/K).'); return; }
  if (!(c.rank==='J' || c.rank==='Q' || c.rank==='K')){ log('Not a Sigil.'); return; }

  const inHand = G.players[myPid()].hand.some(x => x.id === c.id);
  if (!inHand){ G.selected.clear(); render(); log('That card moved. Re-select.'); return; }

  openSigil(c);
}

  function discardSelected(){
    const c = selectedOne();
    if (!c){ log('Select exactly one card to discard for +1.'); return; }
    userAction({type:'DISCARD', pid:myPid(), cardId:c.id});
  }

  function wireButtons(){
const tbtn = $('btnTutorial');
if (tbtn) tbtn.onclick = ()=> openDrawer($('tutorialDrawer'));
    const mbT = $('mbTutorial');
if (mbT) mbT.onclick = ()=> openDrawer($('tutorialDrawer'));
    // Desktop
    $('btnStart').onclick = ()=> userAction({type:'START', pid:myPid()});
    $('btnRules').onclick = ()=> openDrawer($('rulesDrawer'));
    $('btnConstruct').onclick = ()=>{
      const act = attemptConstruct(myPid());
      if (act) userAction(act);
    };
    $('btnAction').onclick = playSelectedAction;
    $('btnSigil').onclick  = playSelectedSigil;
    $('btnDiscard').onclick= discardSelected;

    // Mobile
    $('mbStart').onclick = ()=> userAction({type:'START', pid:myPid()});
    $('mbRules').onclick = ()=> openDrawer($('rulesDrawer'));
    $('mbConstruct').onclick = ()=>{
      const act = attemptConstruct(myPid());
      if (act) userAction(act);
    };
    $('mbAction').onclick = playSelectedAction;
    $('mbSigil').onclick  = playSelectedSigil;
    $('mbDiscard').onclick= discardSelected;

    // Rules close
    $('rulesClose').onclick = ()=> closeDrawer($('rulesDrawer'));

    // Network controls
    const btnConnect = $('btnConnect'), btnDisconnect = $('btnDisconnect');
    if (btnConnect)   btnConnect.onclick   = ()=>{ applySettings(); Net.connect(); };
    if (btnDisconnect)btnDisconnect.onclick= ()=> Net.disconnect();

    // Log collapse
    const toggle = $('toggleLog'), logEl = $('log');
    if (toggle && logEl){
      toggle.onclick = ()=>{
        const collapsed = logEl.classList.toggle('is-collapsed');
        toggle.textContent = collapsed ? 'Show activity' : 'Hide activity';
        toggle.setAttribute('aria-expanded', String(!collapsed));
      };
    }
  }

  // === Boot ===
  (function init(){
    loadPrefs();
    // Respect reduced motion on first load
    if (!Pref.anims) document.body.classList.add('no-anim');

    adjustCardSize();
    updateModeTag();
    wireButtons();

    // Load saved game or start fresh UI
    if (loadState()){
      render();
    } else {
      render(); // empty boards
    }
// Auto-open tutorial the first time
if (!localStorage.getItem(TUTO_KEY)) {
  setTimeout(()=> openDrawer($('tutorialDrawer')), 400);
}  })();

function rankTip(c){
  const r = c.rank;
  if (isPage(c)) return 'Page (Joker): wild; costs 1 extra discard and ‚àí1 point when used in non-Page melds.';
  if (r==='A') return 'Ace: try to block 7/9 (d6: 4‚Äì6 blocks +1); discard 2 to auto-block a Sigil.';
  if (r==='6') return 'Action 6: Draw 2.';
  if (r==='7') return 'Action 7: Steal 1 random card (Ace can try to block).';
  if (r==='9') return 'Action 9: Swap ‚Äî give 1, take 1 (Ace can try to block).';
  if (r==='J') return 'Sigil J: +1 point or draw 1 (can be auto-blocked by 2 Aces).';
  if (r==='Q') return 'Sigil Q: +2 points or draw 1 (can be auto-blocked by 2 Aces).';
  if (r==='K') return 'Sigil K: +3 points or draw 2 (can be auto-blocked by 2 Aces).';
  return 'Normal: make Sets, Runs, or Pairs. Same-suit Runs can trigger suit bonuses.';
}
  </script>
</body>
</html>
